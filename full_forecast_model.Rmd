---
params:
  series: '2hrs ph3'
  model: Arima(order=c(1, 0, 0), seasonal=c(1, 0, 0), method="ML")
  transformation: identity() #log() %>% (function(d) {d[d==-Inf]<-0; d})
  traindays: 7
  testdays: 1
  xreg: NULL
  obs: FALSE
title: '`r params$model` on full `r params$series`'
author: 'Barbu Paul - Gheorghe'
date: '`r Sys.time()`'
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r includes, warning=FALSE, include=FALSE}
library(forecast)
library(ggplot2)
library(tictoc)

source('datasets.R')
source('funcs.R')
```


# Parameters

Series: **`r params$series`**.

Model: **`r params$model`**.

Transformation: **`r params$transformation`**.

As observations: **`r params$obs`**.

Train days: **`r params$traindays`**.

Test days: **`r params$testdays`**.

xreg: **`r params$xreg`**.

# Original data

The data has been previously cleaned, negative values were made 0.

```{r data, echo=FALSE, message=FALSE, warning=FALSE}
fulldata <- datasets[[params$series]]$series
if(params$obs)
{
  totaldays <- length(fulldata)
}else{
  totaldays <- round(length(fulldata)/frequency(fulldata))
}

autoplot(fulldata, series="Full") +
  xlab("Observation [days]") +
  ylab("Energy [Watts]") +
  ggtitle("Original data") + 
  guides(colour=guide_legend(title="Data series"))
```

Total data points: **`r length(fulldata)`** representing
**`r totaldays`** days.

Number of data points per day: **`r frequency(fulldata)`**
(gathered once every **`r (24*60)/frequency(fulldata)`** minutes).

# Forecast data

## Forecasts plot against the data
```{r get-forecast, message=FALSE, include=FALSE}
tic('Forecast')

fcast <- NULL

if(params$obs)
{
  fcast <- fullforecast.obs(fulldata,
                        params$transformation, 
                        params$model, 
                        params$traindays,
                        params$testdays,
                        params$xreg)
}else{
  fcast <- fullforecast(fulldata,
                        params$transformation, 
                        params$model, 
                        params$traindays,
                        params$testdays,
                        params$xreg)
}
fcast.times <- toc()
```

Time elapapsed for forecasting
**`r totaldays - params$traindays`**
`r ifelse(params$obs, "data points", paste("days (representing", frequency(fulldata) * (totaldays - params$traindays), "data points)"))`,
initial training data not taken into account:
**`r fcast.times$toc - fcast.times$tic`** seconds
(**`r (fcast.times$toc - fcast.times$tic)/60`** minutes).

```{r plot-forecast, echo=FALSE}
autoplot(fulldata, series="Original") +
  autolayer(fcast$points, series="Forecasts") +
  xlab("Observation [days]") +
  ylab("Energy [Watts]") +
  ggtitle("Original data and forecasts") + 
  guides(colour=guide_legend(title="Data series"))
```

## Accuracy of the forecasts against the data
```{r forecast-accuracy, echo=FALSE}
knitr::kable(fcast$accuracy)
```

# Future work

* Some models (e.g. with fourier terms for the seasonality) may go into the negative values, this cannot be taken care of during the modelling/forecasting phase with these kind of models (since we cannot control the ampitude of the seasonality in each point) and would have to be corrected after forecasting in order to replace all negative values with zeros