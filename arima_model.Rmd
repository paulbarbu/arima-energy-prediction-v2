---
params:
  series: '2hrs ph3'
  model: Arima(order=c(1, 0, 0), seasonal=c(1, 0, 0))
  transformation: identity() #log() %>% (function(d) {d[d==-Inf]<-0; d})
  diffs: identity() # diff() %>% diff()
  sdiffs: identity() # diff(lag=frequency(data$train))
  startday: -10
  traindays: 7
  testdays: 3
title: '`r params$model` on `r params$series`'
author: 'Barbu Paul - Gheorghe'
date: '`r Sys.time()`'
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r includes, warning=FALSE, include=FALSE}
library(forecast)
library(ggplot2)
library(tictoc)

source('datasets.R')
source('funcs.R')
```

# Original data

## Training & test data
The data has been previously cleaned, negative values were made 0.
Time series 80/20 rule goes in sequential order, not random.

```{r data, echo=FALSE, message=FALSE, warning=FALSE}
data <- get_days(datasets[[params$series]]$series, -10, 7, 3)
autoplot(data$train, series="Train") +
  autolayer(data$test, series="Test") +
  xlab("Observation [days]") +
  ylab("Energy [Watts]") +
  ggtitle("Original data") + 
  guides(colour=guide_legend(title="Data series"))
```

Total data points: **`r length(datasets[[params$series]]$series)`** representing
**`r round(length(datasets[[params$series]]$series)/frequency(data$train))`** days.

Number of data points per day: **`r frequency(data$train)`**
(gathered once every **`r (24*60)/frequency(data$train)`** minutes).

Starting from: **`r params$startday`**.

Train days: **`r params$traindays`**.

Test days: **`r params$testdays`**.

```{r subseries-plots, echo=FALSE, message=FALSE}
season.labels = seq(frequency(data$train))
ggseasonplot(data$train, season.labels = season.labels) +
  xlab("Season") +
  ylab("Energy [Watts]") +
  guides(colour=guide_legend(title="Day")) +
  ggtitle('Seasonal plot for training data')

ggsubseriesplot(data$train, labels = season.labels) +
  xlab("Season") +
  ylab("Energy [Watts]") +
  ggtitle('Subseries plot for each season in the training data') +
  scale_x_continuous(breaks = 0.5 + (1:frequency(data$train)),
                     labels = 1:frequency(data$train))
```

## ACF & PACF of training data

```{r acf-pacf, echo=FALSE}
data$train %>% ggtsdisplay(main='Training data', xlab='Observation [days]', ylab='Energy [Watts]')
```

#Data transformations & differences

## Box-Cox transformation

* Original data points: $y_{1},\dots,y_{T}$
* Transformed data points: $w_{1},\dots,w_{T}$

$$
w_t  =
    \begin{cases}
      \log(y_t)               & \text{if $\lambda=0$};  \\
      (y_t^\lambda-1)/\lambda & \text{otherwise}.
    \end{cases}
$$  

```{r boxcox, echo=FALSE}
lambda <- BoxCox.lambda(data$train)
```

Suggested BoxCox transformation on the training data:
$\mathbf{\lambda=`r lambda`}$

```{r boxcox-applied, echo=FALSE}
autoplot(BoxCox(data$train, lambda)) +
  xlab("Observation [days]") +
  ylab("Transformed energy") +
  ggtitle(bquote("Transformed training data, " ~ lambda ~ " = " ~ .(lambda)))
```

```{r apply-transformation, echo=FALSE}
use_transformation <- !is.null(params$transformation) && params$transformation != 'identity()'

eval(parse(text=paste('data$train %>%',
                      params$transformation))) -> data$train.transformed
```

## Transformation

Transformation: **`r params$transformation`**

```{r plot-transformed-data, echo=FALSE, eval=use_transformation}
autoplot(data$train.transformed) +
  xlab("Observation [days]") +
  ylab("Transformed energy") +
  ggtitle(paste("Transformed data using:", params$transformation)) + 
  guides(colour=guide_legend(title="Data series"))
```

**ATTENTION:** continuing with **`r if(use_transformation) 'transformed' else 'original'`** data!

## ACF & PACF after transforming & differencing the data

Suggested number of differences to make data stationary:
**`r ndiffs(data$train.transformed)`**.

Suggested number of seasonal differences to make data stationary:
**`r nsdiffs(data$train.transformed)`**.

TODO: check the name of the file with diffs & transformations

```{r apply-diffs, echo=FALSE}
use_diffs <- !is.null(params$diffs) && params$diffs != 'identity()'

eval(parse(text=paste('data$train.transformed %>%',
                      params$diffs))) -> data$train.transformed.diffed
```

```{r apply-sdiffs, echo=FALSE}
use_sdiffs <- !is.null(params$sdiffs) && params$sdiffs != 'identity()'

eval(parse(text=paste('data$train.transformed.diffed %>%',
                      params$sdiffs))) -> data$train.transformed.sdiffed
```

### Differences

Differences: **`r params$diffs`**.

```{r plot-diff, echo=FALSE, eval=use_diffs}
data$train.transformed.diffed %>%
  ggtsdisplay(main=paste('Transformed & differenced data using:', params$diffs),
              xlab='Observation [days]',
              ylab='Transformed & differenced energy')
```

### Seasonal differences

Seasonal differences: **`r params$sdiffs`**.

```{r plot-sdiff, echo=FALSE, eval=use_sdiffs}
data$train.transformed.sdiffed %>%
  ggtsdisplay(main=paste('Transformed & diffed & s. diffed data using:',
                         params$diffs, 'and', params$sdiffs), 
              xlab='Observation [days]', 
              ylab='Transformed & diffed & s. diffed energy')
```

# Model fitting & evaluation

```{r model-fitting, include=FALSE}
tic("Model fitting")

#last_week %>% auto.arima(xreg=fourier(last_week, K=2), seasonal=F) -> fit
eval(parse(text=paste('data$train.transformed %>%', params$model))) -> fit

times <- toc()
```

The model **`r params$model`** was evaluated on **`r params$traindays`** days
(representing **`r frequency(data$train.transformed) * params$traindays`** data points)
in **`r times$toc - times$tic`** seconds.

## Model summary

```{r summary-fit}
summary(fit)
```

## Residuals statistics

```{r include=FALSE}
fit %>% residuals() -> data$residuals
```


```{r residuals-stats, echo=FALSE}
checkresiduals(fit,
               xlab='Observation [days]',
               ylab='Energy [Watts]') 
```

Box-Ljung test:

* H~0~ states that the data points are independently distributed.
* High p-value (> 0.05) doesn't reject H~0~.
* If Q\* is large: the autocorrelations do not come from a white noise series
(so Q\* should be small)

```{r residuals-pacf, echo=FALSE}
ggPacf(data$residuals) +
  ggtitle('PACF of residuals')
```

```{r qq-plot, echo=FALSE, message=FALSE}
ggplot(data.frame(y=data$residuals), aes(sample=y)) +
  stat_qq() +
  stat_qq_line() +
  ggtitle('Residuals QQ-plot')
```

## Forecasting
```{r forecast, echo=FALSE, include=FALSE}
tic('Forecast')

fit %>% forecast(h=params$testdays * frequency(data$test)) -> fcast
#fit %>% forecast(xreg=fourier(data$, K=2)) %>% autoplot()

fcast.times <- toc()
```

Time elapapsed for forecasting **`r params$testdays`** days
(representing **`r frequency(data$test) * params$testdays`** data points):
**`r fcast.times$toc - fcast.times$tic`** seconds.

### Accuracy of the forecasts against the test data
```{r accuracy, echo=FALSE}
accuracy(fcast, data$test)
```

### Fitted values and forecasts plot against the real data
```{r fit-forecast-plot, echo=FALSE}
fcast %>% autoplot(series='Forecast') +
  autolayer(fitted(fit), series='Fitted') + 
  autolayer(data$train, series = 'Train') +
  autolayer(data$test, series='Test') +
  xlab("Observation [days]") +
  ylab("Energy [Watts]") +
  guides(colour=guide_legend(title="Data series"), 
         fill=guide_legend(title="Prediction interval"))
```

# Future work

* Add other statistical tests for stationarity, differencing, etc.
* Allow the model to be ran on the manually transformed data (through a param)
* Parallel processing for evaluating multiple models at the same time

# References
* [Forecasting: Principles and Practice, Rob J Hyndman and George Athanasopoulos, Monash University, Australia](https://otexts.org/fpp2/)
* [Statistical forecasting: notes on regression and time series analysis, Robert Nau, Fuqua School of Business, Duke University](http://people.duke.edu/~rnau/411home.htm)
* [Time Series Forecasting: Creating a seasonal ARIMA model using Python and Statsmodel, Sean Abu](http://www.seanabu.com/2016/03/22/time-series-seasonal-ARIMA-model-in-python/)
* [How to Create an ARIMA Model for Time Series Forecasting in Python, Jason Brownlee](https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/)
* [ Introduction to Forecasting with ARIMA in R, Ruslana Dalinina](https://www.datascience.com/blog/introduction-to-forecasting-with-arima-in-r-learn-data-science-tutorials)
* [Seasonal periods, Rob J Hyndman](https://robjhyndman.com/hyndsight/seasonal-periods/)
* [Math Notation for R Plot Titles: expression and bquote, Tyler Rinker](https://www.r-bloggers.com/math-notation-for-r-plot-titles-expression-and-bquote/)